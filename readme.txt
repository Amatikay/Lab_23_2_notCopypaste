Сейчас этот файл я использую как свои заметки по ходу реализации задачи лобрторной работы, когдя я буду считать
лабораторную работу выполненной - удалю файл.



########################################################################################################################
########################################## Постановка задачи ###########################################################
########################################################################################################################
На основе паттерна Наблюдателя, написать программу для слежения за состоянием выбранного файла.

Ограничимся  двумя характеристиками:
1. Существует файл или нет;
2. Каков размер файла.

Программа будет выводить на консоль уведомление о произошедших изменениях в файле.
Существует несколько ситуаций для наблюдаемого файла
1. Файл существует , файл не  пустой - на экран выводится факт существования файла и его  размер.
2. Файл существует, файл был изменен - на экран выводится факт существования файла,
сообщение о том что файл был изменен и его размер.
3. Файл не существует - на экран выводится информация о том что файл не существует.

В главной программе создаем объект для отслеживания состояния конкретного файла,
затем определяется объект наблюдатель, после чего связываем Наблюдателя с Источником.
Можно использовать бесконечный цикл, в котором будем обновлять состояние объекта Источника каждые 100 миллисекунд
(например так  std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );).

########################################################################################################################
########################################## Заметки по реализации #######################################################
########################################################################################################################

При реализации шаблона «наблюдатель» обычно используются следующие классы:

    Observable — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;
                           объект абстрактного наблюдаемого
    Observer — интерфейс, с помощью которого наблюдатель получает оповещение;
                           объект абстрактного наблюдателя
    ConcreteObservable — конкретный класс, который реализует интерфейс Observable;
                           конкретный наблюдаемый
    ConcreteObserver — конкретный класс, который реализует интерфейс Observer.
                           конкретный наблюдатель
------------------------------------------------------------------------------------------------------------------------
Пусть мы будем следить за выбранным пользователем файлом.

!!!!!!!!!!!!!!!!!!!!!!! Требование: Указывать полный путь к файлу !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Возможно впоследствии я придумаю как получать путь откуда вызвана программа, и передавать относительно этого пути
путь до файла за которым следить, но пока ничего лучше, чем вызов в директории файла.
(1) pwd | main [file]
В таком случае у меня будет argv[1] - имя файла argv[2] - путь до файла.
Нужно придумать как передавать файл. Целиком, или как в примере (1).
Хватит концентрироваться на этом. Сначала решить основное, после разбираться с путями и тд и тп.


"2. Файл существует, файл был изменен - на экран выводится факт существования файла,
 сообщение о том что файл был изменен и его размер." - Надеюсь здесь имеется в виду изменен размер файла, иначе
 я не вижу возможности, кроме  как каждый раз проверять хеш сумму файла. Если ограничиться проверкой на размер -
 программа может проигнорировать, если в фале было записано "aaa" заменить на "bbb".


Мне кажется что я запутался с наблюдателем. Весь код сейчас пойдет под снос.

Проблема с проверкой существования файла.
Один из вариантов, но он плох. Файл может не отрыться потому что, уже используется другой программой,
нет прав на открытие файла..
std::ifstream file;
    file.open("file.txt");
    file.close();
    if (file){
    code
    }

Необходимо придумать вариант интерфейса, который будет отслеживать файл не в каждую delta t , а именно
"отлавливать его изменение".



