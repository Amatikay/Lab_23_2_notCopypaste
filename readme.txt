Сейчас этот файл я использую как свои заметки по ходу реализации задачи лобрторной работы, когдя я буду считать
лабораторную работу выполненной - напишу то, что должно быть в Readme.




########################################################################################################################
########################################## Постановка задачи ###########################################################
########################################################################################################################
На основе паттерна Наблюдателя, написать программу для слежения за состоянием выбранного файла.

Ограничимся  двумя характеристиками:
1. Существует файл или нет;
2. Каков размер файла.

Программа будет выводить на консоль уведомление о произошедших изменениях в файле.
Существует несколько ситуаций для наблюдаемого файла
1. Файл существует , файл не  пустой - на экран выводится факт существования файла и его  размер.
2. Файл существует, файл был изменен - на экран выводится факт существования файла,
сообщение о том что файл был изменен и его размер.
3. Файл не существует - на экран выводится информация о том что файл не существует.

В главной программе создаем объект для отслеживания состояния конкретного файла,
затем определяется объект наблюдатель, после чего связываем Наблюдателя с Источником.
Можно использовать бесконечный цикл, в котором будем обновлять состояние объекта Источника каждые 100 миллисекунд
(например так  std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) );).

########################################################################################################################
########################################## Заметки по реализации #######################################################
########################################################################################################################

При реализации шаблона «наблюдатель» обычно используются следующие классы:

    Observable — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;
    Observer — интерфейс, с помощью которого наблюдатель получает оповещение;
    ConcreteObservable — конкретный класс, который реализует интерфейс Observable;
    ConcreteObserver — конкретный класс, который реализует интерфейс Observer.
------------------------------------------------------------------------------------------------------------------------
Пусть мы будем следить за выбранным пользователем файлом.

!!!!!!!!!!!!!!!!!!!!!!! Требование: Указывать полный путь к файлу !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
